---
title: "NMA analysis - Behaviour & fMRI"
author: "Jelka Stojanov"
date: "21/07/2021"
output: html_document
---

Remove scientific notation

```{r}
options(scipen = 999) 
```

Clean and restructure the data
Analyze and plot behavioural data

WM_Behaviour = Dataset with accuracy and reaction times
WM_0back = fMRI data from the 0-back task
WM_2back = fMRI data from the 2-back task

```{r}
WM_Behaviour$Task <- ifelse(WM_Behaviour$ConditionName %in% c('0BK_FACE', '0BK_BODY', '0BK_PLACE', '0BK_TOOL'), '0-back', '2-back')
WM_Behaviour$Stimulus <- ifelse(WM_Behaviour$ConditionName %in% c('0BK_FACE', '2BK_FACE'), 'Faces', 
                         ifelse(WM_Behaviour$ConditionName %in% c('0BK_BODY', '2BK_BODY'), 'Body parts', 
                         ifelse(WM_Behaviour$ConditionName %in% c('0BK_PLACE', '2BK_PLACE'), 'Places', 'Tools')))
```

Initiate raincloud plot

```{r}
# Check if required packages are installed ----
packages <- c("cowplot", "readr", "ggplot2", "dplyr", "lavaan", "smooth", "Hmisc")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))
}

# Load packages ----
library(ggplot2)

"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}

geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                             position = "dodge", trim = TRUE, scale = "area",
                             show.legend = NA, inherit.aes = TRUE, ...) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomFlatViolin,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      trim = trim,
      scale = scale,
      ...
    )
  )
}

#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @export
GeomFlatViolin <-
  ggproto("GeomFlatViolin", Geom,
    setup_data = function(data, params) {
      data$width <- data$width %||%
        params$width %||% (resolution(data$x, FALSE) * 0.9)

      # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
      data %>%
        group_by(group) %>%
        mutate(
          ymin = min(y),
          ymax = max(y),
          xmin = x,
          xmax = x + width / 2
        )
    },

    draw_group = function(data, panel_scales, coord) {
      # Find the points for the line to go all the way around
      data <- transform(data,
        xminv = x,
        xmaxv = x + violinwidth * (xmax - x)
      )

      # Make sure it's sorted properly to draw the outline
      newdata <- rbind(
        plyr::arrange(transform(data, x = xminv), y),
        plyr::arrange(transform(data, x = xmaxv), -y)
      )

      # Close the polygon: Set first and last point the same
      # Needed for coord_polar and such
      newdata <- rbind(newdata, newdata[1, ])

      ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))
    },

    draw_key = draw_key_polygon,

    default_aes = aes(
      weight = 1, colour = "grey20", fill = "white", size = 0.5,
      alpha = NA, linetype = "solid"
    ),

    required_aes = c("x", "y")
  )
```

Create a theme for plots

```{r}
sf <- 1

graph_theme_NMA <-  theme( # Base plot theme
  # Axes
  axis.line.y = element_line(colour = "gray40", size = 0.5, lineend=0),
  axis.line.x = element_line(colour = 'gray40', size = 0.5, lineend=0),
  axis.ticks.x = element_line(colour = 'gray40', size = 0.5, lineend=0),
  strip.text.x = element_text(size = 11*(sf+1.5),  colour = "black"),
  strip.text.y = element_text(size = 11*(sf+1.5),  colour = "black"),
  
  # Axes text
  axis.text.x = element_text(size = 18*(sf+1), family = "sans", colour = "black"), #angle = 45
  axis.text.y = element_text(size = 18*(sf+1), family = "sans", colour = "black"),
  
  # titles
  plot.title = element_text(size = 16*(sf+1.5), hjust = .5),
  axis.title.y=element_text(size = 18*(sf+1.5), margin=margin(0,5,0,0)),
  axis.title.x=element_blank(),

  # panel
  panel.border = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.background = element_rect(fill="transparent"),
  
  # Legend
  legend.position = "top",
  legend.title = element_blank(),
  legend.text = element_text(size = 18*(sf+1.5), family = "sans", colour = "black"),
  legend.background = element_blank(),

  text=element_text(size = 18, family = "sans"),
  strip.background = element_blank())
```

Plot accuracy and reaction time 

```{r}
Accuracy_Summary <- WM_Behaviour %>%
  dplyr::group_by(Subject, Task, Stimulus) %>%
  dplyr::summarise(N = length(ACC), 
            meanAcc = mean(ACC), 
            sdAcc = sd(ACC))


Accuracy_Plot <- Accuracy_Summary %>%
  group_by(Subject, Task, Stimulus) %>%
  ggplot(aes(y = meanAcc, x = Task, fill = Stimulus, colour = Stimulus)) +
  geom_flat_violin(position = position_nudge(x = .3, y = 0), alpha = .3) +
  #geom_boxplot(width = .15, guides = FALSE, outlier.shape = NA, alpha = 0.5) +
  geom_point(aes(y = meanAcc, group = Stimulus), position = position_dodge2(width = 0.4), size = 3, alpha = 0.1) +
  stat_summary(fun = mean, geom = 'pointrange', width = 0.3, size = 2.6, alpha = 1, position=position_dodge(width=0.4)) +
  stat_summary(fun.data = mean_se, geom='errorbar', width = 0.35, size = 2.6, alpha = 1, linetype = "solid",
               position=position_dodge(width=0.4)) +
  #stat_summary(aes(y = meanAcc, group = as.numeric(Subject)), fun.y = mean, geom = "line", size = 2, alpha = 1.2, width = 0.25, colour = 
  #               'gray48', mult = 1) +
  guides(color = FALSE) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  ylab('Accuracy') +
  ylim(0, 1) +
  guides(colour = "legend", group = 'none', fill = 'none', shape = 'none', size = 'none') +
  graph_theme_NMA

ggsave('Accuracy_Plot.png', Accuracy_Plot, device = 'png', dpi = 100, width = 25, height = 15)

RT_Summary <- WM_Behaviour %>%
  dplyr::group_by(Subject, Task, Stimulus) %>%
  dplyr::summarise(N = length(MEDIAN_RT), 
            meanRT = mean(MEDIAN_RT, na.rm = TRUE), 
            sdRT = sd(MEDIAN_RT), na.rm = TRUE)

RT_Plot <- RT_Summary %>%
  group_by(Subject, Task, Stimulus) %>%
  ggplot(aes(y = meanRT, x = Task, fill = Stimulus, colour = Stimulus)) +
  geom_flat_violin(position = position_nudge(x = .3, y = 0), alpha = .3) +
  #geom_boxplot(width = .15, guides = FALSE, outlier.shape = NA, alpha = 0.5) +
  geom_point(aes(y = meanRT, group = Stimulus), position = position_dodge2(width = 0.4), size = 3, alpha = 0.1) +
  stat_summary(fun = mean, geom = 'pointrange', width = 0.3, size = 2.6, alpha = 1, position=position_dodge(width=0.4)) +
  stat_summary(fun.data = mean_se, geom='errorbar', width = 0.35, size = 2.6, alpha = 1, linetype = "solid",
               position=position_dodge(width=0.4)) +
  #stat_summary(aes(y = meanAcc, group = as.numeric(Subject)), fun.y = mean, geom = "line", size = 2, alpha = 1.2, width = 0.25, colour = 
  #               'gray48', mult = 1) +
  guides(color = FALSE) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  ylab('Reaction time (ms)') +
  ylim(0, 1750) +
  guides(colour = "legend", group = 'none', fill = 'none', shape = 'none', size = 'none') +
  graph_theme_NMA

ggsave('RT_Plot.png', RT_Plot, device = 'png', dpi = 100, width = 25, height = 15)
```

Formal analysis of accuracy and reaction time

```{r}
models_Accuracy <- list()

models_Accuracy$Task_Stimulus <- lmer(ACC ~ Task * Stimulus + (1|Subject),
                                      data = WM_Behaviour, 
                                      verbose = TRUE)

summary(models_Accuracy$Task_Stimulus)
anova(models_Accuracy$Task_Stimulus) # Significant main effect of task, stimulus, and task x stimulus interaction

emmeans::emmip(models_Accuracy$Task_Stimulus, ~ Task, cov.reduce = range) # Lower performance in 2-back
emmeans::emmip(models_Accuracy$Task_Stimulus, ~ Stimulus, cov.reduce = range) # Faces = Places > Gools > Body parts
emmeans::emmip(models_Accuracy$Task_Stimulus, ~ Task ~ Stimulus, cov.reduce = range)

lsmeans(models_Accuracy$Task_Stimulus, pairwise ~ Task | Stimulus, cov.reduce = range, adjust = 'bonferroni', lmerTest.limit = 4767)
lsmeans(models_Accuracy$Task_Stimulus, pairwise ~ Stimulus | Task, cov.reduce = range, adjust = 'bonferroni', lmerTest.limit = 4767) # In summary, in the 0-back task Faces = Places = Tools (Faces > Tools) > Body parts, and in the 2-back task Faces = Places > Tools > Body parts. Faces and places are social info while tools and body parts are not and are more decontextualized?

models_RT <- list()

models_RT$Task_Stimulus <- lmer(MEDIAN_RT ~ Task * Stimulus + (1|Subject),
                                      data = WM_Behaviour, 
                                      verbose = TRUE)

summary(models_RT$Task_Stimulus)
anova(models_RT$Task_Stimulus) # Significant main effect of task, stimulus, and task x stimulus interaction

emmeans::emmip(models_RT$Task_Stimulus, ~ Task, cov.reduce = range) # Longer RT for 2-back
emmeans::emmip(models_RT$Task_Stimulus, ~ Stimulus, cov.reduce = range) # Longer RT for body parts in comparison to other stimuli
emmeans::emmip(models_RT$Task_Stimulus, ~ Task ~ Stimulus, cov.reduce = range) 

lsmeans(models_RT$Task_Stimulus, pairwise ~ Task | Stimulus, cov.reduce = range, adjust = 'bonferroni', lmerTest.limit = 4767)
lsmeans(models_RT$Task_Stimulus, pairwise ~ Stimulus | Task, cov.reduce = range, adjust = 'bonferroni', lmerTest.limit = 4767) # In summary, in the 0-back task Body parts > Places = Faces = Tools (some differences are trending, that's why there is a significant interaction), and in the 2-back task Body parts > Places = Faces = Tools.
```